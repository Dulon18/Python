# Day 13: Error Handling

## Overview
Today we'll learn how to handle errors gracefully using Python's exception handling system. Writing robust code means anticipating problems and handling them elegantly instead of crashing!

---

## 1. Introduction to Exceptions

### What are Exceptions?

Exceptions are errors that occur during program execution. Without handling them, your program crashes.

### Common Built-in Exceptions

```python
# ZeroDivisionError
result = 10 / 0

# ValueError
number = int("abc")

# TypeError
result = "5" + 5

# IndexError
my_list = [1, 2, 3]
item = my_list[10]

# KeyError
my_dict = {"name": "Alice"}
age = my_dict["age"]

# FileNotFoundError
file = open("nonexistent.txt")

# AttributeError
number = 5
number.append(10)
```

---

## 2. The try-except Block

### Basic Syntax

```python
try:
    # Code that might raise an exception
    risky_code()
except:
    # Code to handle the exception
    print("An error occurred!")
```

### Simple Example

```python
try:
    number = int(input("Enter a number: "))
    result = 10 / number
    print(f"Result: {result}")
except:
    print("Something went wrong!")
```

---

## 3. Catching Specific Exceptions

Handle different errors differently.

### Single Exception Type

```python
try:
    number = int(input("Enter a number: "))
    result = 10 / number
except ZeroDivisionError:
    print("Error: Cannot divide by zero!")
```

### Multiple Exception Types

```python
try:
    number = int(input("Enter a number: "))
    result = 10 / number
    print(f"Result: {result}")
except ZeroDivisionError:
    print("Error: Cannot divide by zero!")
except ValueError:
    print("Error: Please enter a valid number!")
```

### Catching Multiple Exceptions Together

```python
try:
    # Some code
    pass
except (ValueError, TypeError):
    print("Error: Invalid input type!")
```

### Accessing Exception Details

```python
try:
    number = int(input("Enter a number: "))
except ValueError as e:
    print(f"Error occurred: {e}")
    print(f"Error type: {type(e).__name__}")
```

---

## 4. The else Clause

Executes if no exception occurred.

```python
try:
    number = int(input("Enter a number: "))
    result = 10 / number
except ValueError:
    print("Invalid number!")
except ZeroDivisionError:
    print("Cannot divide by zero!")
else:
    print(f"Success! Result: {result}")
```

### When to Use else

✅ Code that should only run if no exception occurred  
✅ Separating error-prone code from success code  
✅ Making code more readable  

```python
try:
    file = open("data.txt", "r")
except FileNotFoundError:
    print("File not found!")
else:
    # This only runs if file was opened successfully
    content = file.read()
    print(content)
    file.close()
```

---

## 5. The finally Clause

Always executes, regardless of exceptions.

```python
try:
    file = open("data.txt", "r")
    content = file.read()
except FileNotFoundError:
    print("File not found!")
else:
    print("File read successfully!")
finally:
    # This ALWAYS runs
    print("Cleanup complete!")
```

### Common Use Cases for finally

✅ Closing files  
✅ Closing database connections  
✅ Releasing resources  
✅ Cleanup operations  

```python
file = None
try:
    file = open("data.txt", "r")
    content = file.read()
except FileNotFoundError:
    print("File not found!")
finally:
    if file:
        file.close()
        print("File closed")
```

---

## 6. Complete try-except Structure

### All Clauses Together

```python
try:
    # Code that might raise an exception
    number = int(input("Enter a number: "))
    result = 10 / number
except ValueError:
    # Handle ValueError
    print("Please enter a valid number!")
except ZeroDivisionError:
    # Handle ZeroDivisionError
    print("Cannot divide by zero!")
else:
    # Runs if no exception occurred
    print(f"Result: {result}")
finally:
    # Always runs
    print("Operation complete!")
```

### Execution Flow

```python
# Normal execution (no errors)
try:          # ✓ Executes
    pass
except:       # ✗ Skipped
    pass
else:         # ✓ Executes
    pass
finally:      # ✓ Executes
    pass

# With exception
try:          # ✓ Executes (until error)
    raise ValueError()
except:       # ✓ Executes
    pass
else:         # ✗ Skipped
    pass
finally:      # ✓ Executes
    pass
```

---

## 7. Raising Exceptions

### Using raise

```python
def divide(a, b):
    """Divide two numbers."""
    if b == 0:
        raise ValueError("Divisor cannot be zero!")
    return a / b

try:
    result = divide(10, 0)
except ValueError as e:
    print(f"Error: {e}")
```

### Raising Different Exception Types

```python
def check_age(age):
    """Validate age."""
    if age < 0:
        raise ValueError("Age cannot be negative!")
    if age > 150:
        raise ValueError("Age is unrealistic!")
    if not isinstance(age, int):
        raise TypeError("Age must be an integer!")
    return True

try:
    check_age(-5)
except ValueError as e:
    print(f"Value Error: {e}")
except TypeError as e:
    print(f"Type Error: {e}")
```

### Re-raising Exceptions

```python
def process_data(data):
    try:
        # Process data
        result = int(data)
    except ValueError:
        print("Logging error...")
        raise  # Re-raise the same exception

try:
    process_data("abc")
except ValueError:
    print("Caught in outer handler")
```

---

## 8. Custom Exceptions

Create your own exception classes.

### Basic Custom Exception

```python
class InvalidAgeError(Exception):
    """Raised when age is invalid."""
    pass

def set_age(age):
    if age < 0 or age > 150:
        raise InvalidAgeError(f"Invalid age: {age}")
    return age

try:
    age = set_age(-5)
except InvalidAgeError as e:
    print(f"Error: {e}")
```

### Custom Exception with Details

```python
class InsufficientFundsError(Exception):
    """Raised when account has insufficient funds."""
    
    def __init__(self, balance, amount):
        self.balance = balance
        self.amount = amount
        self.message = f"Insufficient funds: ${balance} available, ${amount} required"
        super().__init__(self.message)

def withdraw(balance, amount):
    if amount > balance:
        raise InsufficientFundsError(balance, amount)
    return balance - amount

try:
    new_balance = withdraw(100, 150)
except InsufficientFundsError as e:
    print(e.message)
    print(f"Short by: ${e.amount - e.balance}")
```

---

## 9. Common Exception Handling Patterns

### Input Validation Loop

```python
def get_positive_number():
    """Get positive number from user."""
    while True:
        try:
            number = int(input("Enter a positive number: "))
            if number <= 0:
                print("Number must be positive!")
                continue
            return number
        except ValueError:
            print("Please enter a valid number!")

result = get_positive_number()
print(f"You entered: {result}")
```

### Safe Type Conversion

```python
def safe_int(value, default=0):
    """Convert to int safely."""
    try:
        return int(value)
    except (ValueError, TypeError):
        return default

print(safe_int("123"))      # 123
print(safe_int("abc"))      # 0
print(safe_int("abc", -1))  # -1
```

### Safe Dictionary Access

```python
def safe_get(dictionary, key, default=None):
    """Get value from dict safely."""
    try:
        return dictionary[key]
    except KeyError:
        return default

data = {"name": "Alice", "age": 25}
print(safe_get(data, "name"))     # Alice
print(safe_get(data, "email"))    # None
print(safe_get(data, "email", "not provided"))  # not provided
```

### File Operations

```python
def read_file(filename):
    """Read file with error handling."""
    try:
        with open(filename, 'r') as file:
            return file.read()
    except FileNotFoundError:
        print(f"Error: File '{filename}' not found")
        return None
    except PermissionError:
        print(f"Error: No permission to read '{filename}'")
        return None
    except Exception as e:
        print(f"Unexpected error: {e}")
        return None

content = read_file("data.txt")
if content:
    print(content)
```

---

## 10. Exception Hierarchy

Understanding the exception hierarchy helps catch exceptions effectively.

```
BaseException
├── SystemExit
├── KeyboardInterrupt
├── Exception
    ├── ArithmeticError
    │   ├── ZeroDivisionError
    │   ├── FloatingPointError
    │   └── OverflowError
    ├── LookupError
    │   ├── IndexError
    │   └── KeyError
    ├── ValueError
    ├── TypeError
    ├── AttributeError
    ├── NameError
    └── ... (many more)
```

### Catching Base Exceptions

```python
try:
    # Some code
    pass
except LookupError:
    # Catches both IndexError and KeyError
    print("Lookup error occurred")

try:
    # Some code
    pass
except ArithmeticError:
    # Catches ZeroDivisionError, OverflowError, etc.
    print("Arithmetic error occurred")
```

---

## 11. Best Practices

### 1. Be Specific with Exceptions

```python
# ❌ Bad - catches everything
try:
    number = int(input())
except:
    print("Error!")

# ✅ Good - specific exception
try:
    number = int(input())
except ValueError:
    print("Please enter a valid number!")
```

### 2. Don't Catch Too Much

```python
# ❌ Bad - catches too much
try:
    data = read_file()
    process_data(data)
    save_results()
except Exception:
    print("Something went wrong!")

# ✅ Better - separate try blocks
try:
    data = read_file()
except FileNotFoundError:
    print("File not found!")

try:
    process_data(data)
except ValueError:
    print("Invalid data!")
```

### 3. Use else for Success Code

```python
# ✅ Good - clear separation
try:
    file = open("data.txt")
except FileNotFoundError:
    print("File not found!")
else:
    content = file.read()
    file.close()
    print(f"Read {len(content)} characters")
```

### 4. Always Clean Up with finally

```python
# ✅ Good - guaranteed cleanup
file = None
try:
    file = open("data.txt")
    content = file.read()
except FileNotFoundError:
    print("File not found!")
finally:
    if file:
        file.close()
```

### 5. Don't Silence Exceptions

```python
# ❌ Bad - hides problems
try:
    important_operation()
except:
    pass  # Silent failure!

# ✅ Good - at least log it
try:
    important_operation()
except Exception as e:
    print(f"Warning: Operation failed - {e}")
```

### 6. Provide Helpful Error Messages

```python
# ❌ Bad - not helpful
raise ValueError("Invalid input")

# ✅ Good - descriptive
raise ValueError(f"Invalid age: {age}. Must be between 0 and 150")
```

---

## 12. Context Managers (with statement)

Automatic resource management.

### Basic with Statement

```python
# Old way
file = open("data.txt", "r")
try:
    content = file.read()
finally:
    file.close()

# Better way - automatic cleanup
with open("data.txt", "r") as file:
    content = file.read()
# File automatically closed here
```

### Multiple Context Managers

```python
with open("input.txt", "r") as infile, open("output.txt", "w") as outfile:
    content = infile.read()
    outfile.write(content.upper())
# Both files automatically closed
```

---

## 13. Practical Examples

### Example 1: Safe Calculator

```python
def safe_divide(a, b):
    """Divide with error handling."""
    try:
        result = a / b
    except ZeroDivisionError:
        print("Error: Division by zero!")
        return None
    except TypeError:
        print("Error: Invalid types for division!")
        return None
    else:
        return result

print(safe_divide(10, 2))    # 5.0
print(safe_divide(10, 0))    # Error: Division by zero! / None
print(safe_divide(10, "2"))  # Error: Invalid types! / None
```

### Example 2: User Input Validator

```python
def get_validated_input(prompt, validator, error_msg):
    """Get and validate user input."""
    while True:
        try:
            value = input(prompt)
            if validator(value):
                return value
            else:
                print(error_msg)
        except KeyboardInterrupt:
            print("\nInput cancelled by user")
            return None

# Usage
age = get_validated_input(
    "Enter your age: ",
    lambda x: x.isdigit() and 0 <= int(x) <= 150,
    "Please enter a valid age (0-150)"
)
```

### Example 3: Retry Logic

```python
def retry_operation(func, max_attempts=3):
    """Retry an operation multiple times."""
    for attempt in range(max_attempts):
        try:
            return func()
        except Exception as e:
            print(f"Attempt {attempt + 1} failed: {e}")
            if attempt == max_attempts - 1:
                print("All attempts failed!")
                raise
    return None

# Usage
def unstable_function():
    import random
    if random.random() < 0.7:
        raise ConnectionError("Network error")
    return "Success!"

try:
    result = retry_operation(unstable_function)
    print(result)
except ConnectionError:
    print("Operation failed after all retries")
```

---

## Practice Exercises

### Exercise 1: Safe List Access
Create a function that safely accesses list elements by index, returning a default value if index is invalid.

### Exercise 2: Temperature Converter
Build a temperature converter with full error handling for invalid inputs.

### Exercise 3: File Processor
Create a program that reads multiple files, handling all possible file-related errors.

### Exercise 4: Custom Validation Exception
Create custom exceptions for a user registration system (InvalidEmailError, WeakPasswordError, etc.).

### Exercise 5: Transaction System
Build a simple banking transaction system with proper exception handling for insufficient funds, invalid amounts, etc.

---

## Practice Project

**See:** `day13_error_handler.py` for the complete Robust Application Framework project.

The project includes:
- Comprehensive error handling
- Custom exceptions
- Input validation
- File operations with error handling
- Retry mechanisms
- Logging and debugging

---

## Quick Reference

### try-except Structure

```python
try:
    # Risky code
    pass
except SpecificError:
    # Handle specific error
    pass
except (Error1, Error2):
    # Handle multiple errors
    pass
except Exception as e:
    # Catch all other exceptions
    print(f"Error: {e}")
else:
    # Runs if no exception
    pass
finally:
    # Always runs
    pass
```

### Common Exceptions

```python
ValueError          # Invalid value
TypeError           # Wrong type
IndexError          # List index out of range
KeyError            # Dictionary key not found
ZeroDivisionError   # Division by zero
FileNotFoundError   # File doesn't exist
AttributeError      # Invalid attribute
NameError           # Variable not defined
```

### Raising Exceptions

```python
raise ValueError("Message")
raise TypeError(f"Expected int, got {type(x)}")
raise  # Re-raise current exception
```

---

## Key Takeaways

✅ Use try-except to handle errors gracefully  
✅ Catch specific exceptions, not generic Exception  
✅ Use else for code that runs on success  
✅ Use finally for cleanup code  
✅ Raise exceptions with descriptive messages  
✅ Create custom exceptions for domain-specific errors  
✅ Don't silence exceptions with empty except blocks  
✅ Use with statement for resource management  
✅ Validate input at entry points  
✅ Log errors for debugging  

---

## Common Mistakes to Avoid

❌ **Catching too broadly**
```python
try:
    everything()
except:  # Catches everything, even Ctrl+C!
    pass
```

❌ **Silencing exceptions**
```python
try:
    important_operation()
except:
    pass  # Bad! What went wrong?
```

❌ **Not cleaning up resources**
```python
file = open("data.txt")
data = file.read()
# File never closed if error occurs!
```

❌ **Using exceptions for control flow**
```python
# Bad
try:
    while True:
        item = next(iterator)
except StopIteration:
    pass

# Good
for item in iterator:
    pass
```

---

## Next Steps

Tomorrow (Day 14), we'll complete Week 2 with a **comprehensive review and build a Banking System** that combines all Week 2 concepts!

---

## Resources

- [Python Exceptions Documentation](https://docs.python.org/3/tutorial/errors.html)
- [Built-in Exceptions](https://docs.python.org/3/library/exceptions.html)

---

**Handle Errors Like a Pro!**